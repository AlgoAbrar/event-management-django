I have a pre built project and now I want to extend following features,

Requirements & Instructions:
1. Authentication 
Implement user authentication features:
User signup with username, email and password, first_name, last_name.
Login and logout functionality.

2. Role-Based Access Control (RBAC) 
Define roles for users:
Admin: Full access to all features. Only the admin can change roles, create groups, delete groups, and delete participants.
Organizer: Can create, update, and delete events and categories
Participant: Replace Participant model with User model. Participants can only view events. 
Use Django Groups to assign roles to users.
Restrict access to views based on roles using decorators.

3. RSVP System 
Participants must be able to RSVP to events they are interested in. Their will be a RSVP button on the event details page.
Store RSVP responses in a ManyToMany relationship between Users and Events.
Ensure that a user cannot RSVP more than once for the same event.
Add a confirmation email when a user RSVPs for an event.
Provide a way for users to view events they have RSVP’d to in their Participant Dashboard.

4. Email Activation 
Upon signup, send an activation email to the user.
Include a secure activation link in the email.
Prevent unactivated users from logging in.
Use Django’s default_token_generator for activation.

5. Django Signals & Media Files(15 Marks)
Automate processes using signals:
Send an email notification to participants when they RSVP’d an event
Send account activation email to registered email
Add ImageField For Event Model. Must give a default value with a default image

6. Maintain User-Specific Dashboards 
Redirect users to their respective dashboards after login:
Admin Dashboard: Manage all events, participants, and categories. (if login user is Admin)
Organizer Dashboard: Manage only events and categories. (if Login user is Organizer)
Participant Dashboard: View events they have RSVP’d to. (if login user is Participant)

recheck my code according to this. And we will work on frontend. solve if there is any error in backend.

I have 3 app folder:

1. core app folder:
/views.py:
from django.shortcuts import render

# Create your views here.

def home(request):
    return render(request, 'home.html')

def no_permission(request):
    return render(request, 'no_permission.html')

/apps.py:
from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'

core/templates:
here will be all the base html files like
base.html
home.html
logged_nav.html
non_logged_nav.html
no_permission.html


2. event app folder:

/views.py:
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required, user_passes_test
from django.db.models import Q
from django.contrib import messages
from django.utils import timezone

from .models import Event, Category, RSVP
from .forms import EventForm, CategoryForm
from django.contrib.auth.models import Group, User


# --- Role ---
def is_admin(user):
    return user.groups.filter(name='Admin').exists()

def is_organizer(user):
    return user.groups.filter(name='Organizer').exists()

def is_participant(user):
    return user.groups.filter(name='Participant').exists()


# --- Dashboard ---
@login_required
def dashboard_redirect(request):
    if is_admin(request.user):
        return redirect('admin-dashboard')
    elif is_organizer(request.user):
        return redirect('organizer-dashboard')
    elif is_participant(request.user):
        return redirect('participant-dashboard')
    return redirect('event-list')


# --- Admin ---
@login_required
@user_passes_test(is_admin)
def admin_dashboard(request):
    today = timezone.now().date()
    context = {
        'total_events': Event.objects.count(),
        'total_participants': RSVP.objects.values('user').distinct().count(),
        'upcoming_events_count': Event.objects.filter(date__gte=today).count(),
        'past_events_count': Event.objects.filter(date__lt=today).count(),
        'todays_events': Event.objects.filter(date=today),
    }
    return render(request, 'dashboard/admin_dashboard.html', context)


# --- Organizer ---
@login_required
@user_passes_test(is_organizer)
def organizer_dashboard(request):
    event_type = request.GET.get('type', 'all')
    today = timezone.now().date()
    base_query = Event.objects.select_related('category')

    if event_type == 'upcoming':
        events = base_query.filter(date__gte=today)
    elif event_type == 'past':
        events = base_query.filter(date__lt=today)
    elif event_type == 'today':
        events = base_query.filter(date=today)
    else:
        events = base_query.all()

    context = {
        'events': events,
        'total_events': base_query.count(),
        'upcoming_events_count': base_query.filter(date__gte=today).count(),
        'past_events_count': base_query.filter(date__lt=today).count(),
    }
    return render(request, 'dashboard/organizer_dashboard.html', context)


# --- Participant ---
@login_required
@user_passes_test(is_participant)
def participant_dashboard(request):
    rsvp_events = Event.objects.filter(rsvps__user=request.user)
    return render(request, 'dashboard/participant_dashboard.html', {'rsvp_events': rsvp_events})


# --- Event List ---
@login_required
def event_list(request):
    search_query = request.GET.get('search', '')
    events = Event.objects.select_related('category')

    if search_query:
        events = events.filter(
            Q(name__icontains=search_query) | Q(location__icontains=search_query)
        )

    return render(request, 'events/show_events.html', {'events': events})


# --- RSVP ---
@login_required
@user_passes_test(is_participant)
def rsvp_event(request, event_id):
    try:
        event = Event.objects.get(pk=event_id)
    except Event.DoesNotExist:
        messages.error(request, "Event not found.")
        return redirect('event-list')

    rsvp_exists = RSVP.objects.filter(user=request.user, event=event).exists()

    if not rsvp_exists:
        RSVP.objects.create(user=request.user, event=event)
        messages.success(request, f"You have successfully RSVP’d to {event.name}.")
    else:
        messages.warning(request, f"You have already RSVP’d to {event.name}.")

    return redirect('participant-dashboard')


# --- Category ---
@login_required
@user_passes_test(is_admin)
def category_list(request):
    categories = Category.objects.all()
    return render(request, 'category/show_category.html', {'categories': categories})


# --- Create ---
@login_required
@user_passes_test(is_admin)
def category_create(request):
    form = CategoryForm(request.POST or None)
    if form.is_valid():
        form.save()
        return redirect('category-list')
    return render(request, 'category/category_form.html', {'form': form})


# --- Update ---
@login_required
@user_passes_test(is_admin)
def category_update(request, pk):
    try:
        category = Category.objects.get(pk=pk)
    except Category.DoesNotExist:
        messages.error(request, "Category not found.")
        return redirect('category-list')

    form = CategoryForm(request.POST or None, instance=category)
    if form.is_valid():
        form.save()
        return redirect('category-list')
    return render(request, 'category/category_form.html', {'form': form})


# --- Delete ---
@login_required
@user_passes_test(is_admin)
def category_delete(request, pk):
    try:
        category = Category.objects.get(pk=pk)
        category.delete()
    except Category.DoesNotExist:
        messages.error(request, "Category not found.")
    return redirect('category-list')


# --- Event ---
@login_required
@user_passes_test(is_organizer)
def event_create(request):
    form = EventForm(request.POST or None, request.FILES or None)
    if form.is_valid():
        form.save()
        return redirect('event-list')
    return render(request, 'events/events_form.html', {'form': form})


# --- Update ---
@login_required
@user_passes_test(is_organizer)
def event_update(request, pk):
    try:
        event = Event.objects.get(pk=pk)
    except Event.DoesNotExist:
        messages.error(request, "Event not found.")
        return redirect('event-list')

    form = EventForm(request.POST or None, request.FILES or None, instance=event)
    if form.is_valid():
        form.save()
        return redirect('event-list')
    return render(request, 'events/events_form.html', {'form': form})


# --- Delete ---
@login_required
@user_passes_test(is_admin)
def event_delete(request, pk):
    try:
        event = Event.objects.get(pk=pk)
        event.delete()
    except Event.DoesNotExist:
        messages.error(request, "Event not found.")
    return redirect('event-list')


# --- Detail ---
@login_required
def event_detail(request, pk):
    try:
        event = Event.objects.get(pk=pk)
    except Event.DoesNotExist:
        messages.error(request, "Event not found.")
        return redirect('event-list')

    rsvp_status = RSVP.objects.filter(user=request.user, event=event).exists()
    return render(request, 'events/event_detail.html', {
        'event': event,
        'rsvp_status': rsvp_status
    })

/signals.py:
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.core.mail import send_mail
from django.conf import settings
from .models import RSVP


@receiver(post_save, sender=RSVP)
def send_rsvp_confirmation_email(sender, instance, created, **kwargs):
    if created:
        user = instance.user
        event = instance.event
        subject = f"RSVP Confirmation for {event.name}"
        message = (
            f"Hi {user.first_name or user.username},\n\n"
            f"You have successfully booked to '{event.name}' on {event.date} at {event.time}.\n"
            f"Location: {event.location}\n\n"
            f"Thank you for joining!\n"
            f"Best Regards,\n"
            f"Saiyedul Abrar\n\n"
        )
        try:
            send_mail(
                subject,
                message,
                 "saiyedul.abrar1430@gmail.com",
                [user.email],
                fail_silently=False
            )
        except Exception as e:
            print(f"Failed to send RSVP email to {user.email}: {str(e)}")


/models.py:
from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone


class Category(models.Model):
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True, null=True)

    def __str__(self):
        return self.name


class Event(models.Model):
    name = models.CharField(max_length=200)
    description = models.TextField()
    date = models.DateField()
    time = models.TimeField()
    location = models.CharField(max_length=255)
    category = models.ForeignKey(
        Category,
        on_delete=models.CASCADE,
        related_name='events'
    )
    image = models.ImageField(
        upload_to='event_images/',
        default='event_images/default.jpg',
        blank=True,
        null=True
    )
    participants = models.ManyToManyField(
        User,
        through='RSVP',
        related_name='rsvp_events'
    )

    def __str__(self):
        return self.name


class RSVP(models.Model):
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='rsvps'
    )
    event = models.ForeignKey(
        Event,
        on_delete=models.CASCADE,
        related_name='rsvps'
    )
    timestamp = models.DateTimeField(default=timezone.now)

    class Meta:
        unique_together = ('user', 'event')

    def __str__(self):
        return f"{self.user.username} RSVP’d to {self.event.name}"


/forms.py:
from django import forms
from .models import Event, Category, RSVP

class StyledFormMixin:
    default_classes = (
        "border-2 border-gray-300 w-full p-3 rounded-lg shadow-sm "
        "focus:outline-none focus:border-rose-500 focus:ring-rose-500"
    )

    def apply_styled_widgets(self):
        for field_name, field in self.fields.items():
            widget = field.widget
            if isinstance(widget, forms.TextInput):
                widget.attrs.update({
                    'class': self.default_classes,
                    'placeholder': f"Enter {field.label.lower()}",
                })
            elif isinstance(widget, forms.Textarea):
                widget.attrs.update({
                    'class': f"{self.default_classes} resize-none",
                    'placeholder': f"Enter {field.label.lower()}",
                    'rows': 5,
                })
            elif isinstance(widget, (forms.SelectDateWidget, forms.DateInput)):
                widget.attrs.update({
                    "class": self.default_classes,
                    "type": "date",
                })
            elif isinstance(widget, forms.TimeInput):
                widget.attrs.update({
                    "class": self.default_classes,
                    "type": "time",
                })
            elif isinstance(widget, forms.CheckboxSelectMultiple):
                widget.attrs.update({
                    'class': "space-y-2",
                })
            elif isinstance(widget, forms.Select):
                widget.attrs.update({
                    'class': self.default_classes,
                })
            else:
                widget.attrs.update({
                    'class': self.default_classes,
                })


class EventForm(StyledFormMixin, forms.ModelForm):
    class Meta:
        model = Event
        fields = ['name', 'description', 'date', 'time', 'location', 'category', 'image']
        widgets = {
            'description': forms.Textarea,
            'date': forms.DateInput(attrs={'type': 'date'}),
            'time': forms.TimeInput(attrs={'type': 'time'}),
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.apply_styled_widgets()


class CategoryForm(StyledFormMixin, forms.ModelForm):
    class Meta:
        model = Category
        fields = ['name', 'description']
        widgets = {
            'description': forms.Textarea,
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.apply_styled_widgets()


class RSVPForm(forms.ModelForm):
    """Form for participants to RSVP to an event."""
    class Meta:
        model = RSVP
        fields = ['user', 'event'] 

    def save(self, commit=True):
        instance = super().save(commit=False)
        if commit:
            instance.save()
        return instance

/apps.py:
from django.apps import AppConfig

class EventConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'event'

    def ready(self):
        import event.signals


/urls.py:
from django.urls import path
from . import views

urlpatterns = [
    # Dashboard
    path('', views.dashboard_redirect, name='dashboard'),

    # role
    path('admin-dashboard/', views.admin_dashboard, name='admin-dashboard'),
    path('organizer-dashboard/', views.organizer_dashboard, name='organizer-dashboard'),
    path('participant-dashboard/', views.participant_dashboard, name='participant-dashboard'),

    # Events
    path('events/', views.event_list, name='event-list'),
    path('events/create/', views.event_create, name='event-create'),
    path('events/<int:pk>/', views.event_detail, name='event-detail'),
    path('events/update/<int:pk>/', views.event_update, name='event-update'),
    path('events/delete/<int:pk>/', views.event_delete, name='event-delete'),
    path('events/<int:event_id>/rsvp/', views.rsvp_event, name='event-rsvp'),

    # Categories
    path('categories/', views.category_list, name='category-list'),
    path('categories/create/', views.category_create, name='category-create'),
    path('categories/update/<int:pk>/', views.category_update, name='category-update'),
    path('categories/delete/<int:pk>/', views.category_delete, name='category-delete'),
]


here I have templates folder too which will have required html files. I haven't created any html files in event/templates

3. users app folder:
/views.py:
from django.shortcuts import render, redirect, HttpResponse
from django.contrib.auth.models import User, Group
from django.contrib.auth import login, logout
from django.contrib.auth.tokens import default_token_generator
from django.contrib.auth.decorators import login_required, user_passes_test
from django.db.models import Prefetch
from django.contrib import messages
from users.forms import CustomRegistrationForm, AssignRoleForm, CreateGroupForm, LoginForm

# Role
def is_admin(user):
    return user.groups.filter(name='Admin').exists()

def is_organizer(user):
    return user.groups.filter(name='Organizer').exists()

def is_participant(user):
    return user.groups.filter(name='Participant').exists()

# Signup view
def sign_up(request):
    form = CustomRegistrationForm()
    if request.method == 'POST':
        form = CustomRegistrationForm(request.POST)
        if form.is_valid():
            user = form.save(commit=False)
            user.set_password(form.cleaned_data.get('password1'))
            user.is_active = False 
            user.save()
            messages.success(request, 'A confirmation email has been sent. Please check your inbox to activate your account.')
            return redirect('sign-in')
        else:
            messages.error(request, 'Please correct the errors below.')
    return render(request, 'registration/register.html', {"form": form})

# Login view
def sign_in(request):
    form = LoginForm()
    if request.method == 'POST':
        form = LoginForm(data=request.POST)
        if form.is_valid():
            user = form.get_user()
            if not user.is_active:
                messages.error(request, 'Your account is not activated. Please check your email.')
                return redirect('sign-in')
            login(request, user)

            
            if is_admin(user):
                return redirect('admin-dashboard')
            elif is_organizer(user):
                return redirect('organizer-dashboard')  
            elif is_participant(user):
                return redirect('participant-dashboard')  
            else:
                return redirect('home')
    return render(request, 'registration/login.html', {'form': form})

@login_required
def sign_out(request):
    if request.method == 'POST':
        logout(request)
        return redirect('sign-in')
    
    return render(request, 'registration/logout.html')

# Account activation
# def activate_user(request, user_id, token):
#     try:
#         user = User.objects.get(id=user_id)
#         if default_token_generator.check_token(user, token):
#             user.is_active = True
#             user.save()
#             messages.success(request, 'Your account has been activated successfully. You can now log in.')
#             return redirect('sign-in')
#         else:
#             return HttpResponse('Invalid activation link or token.', status=400)
#     except User.DoesNotExist:
#         return HttpResponse('User not found.', status=404)

def activate_user(request, user_id, token):
    try:
        user = User.objects.get(id=user_id)
        if default_token_generator.check_token(user, token):
            user.is_active = True
            user.save()
            return redirect('sign-in')
        else:
            return HttpResponse('Invalid Id or token')

    except User.DoesNotExist:
        return HttpResponse('User not found')

# Admin dashboard
@user_passes_test(is_admin, login_url='no-permission')
def admin_dashboard(request):
    users = User.objects.prefetch_related(
        Prefetch('groups', queryset=Group.objects.all(), to_attr='all_groups')
    ).all()

    for user in users:
        user.group_name = user.all_groups[0].name if user.all_groups else 'No Group Assigned'

    return render(request, 'admin/dashboard.html', {"users": users})

# Admin assign roles
@user_passes_test(is_admin, login_url='no-permission')
def assign_role(request, user_id):
    user = User.objects.get(id=user_id)
    form = AssignRoleForm()

    if request.method == 'POST':
        form = AssignRoleForm(request.POST)
        if form.is_valid():
            role = form.cleaned_data.get('role')
            user.groups.clear()
            user.groups.add(role)
            messages.success(request, f"User {user.username} has been assigned the role '{role.name}'.")
            return redirect('admin-dashboard')

    return render(request, 'admin/assign_role.html', {"form": form, "user": user})

# Admin create groups/roles
@user_passes_test(is_admin, login_url='no-permission')
def create_group(request):
    form = CreateGroupForm()
    if request.method == 'POST':
        form = CreateGroupForm(request.POST)
        if form.is_valid():
            group = form.save()
            messages.success(request, f"Group '{group.name}' has been created successfully.")
            return redirect('create-group')

    return render(request, 'admin/create_group.html', {'form': form})

# Admin view
@user_passes_test(is_admin, login_url='no-permission')
def group_list(request):
    groups = Group.objects.prefetch_related('permissions').all()
    return render(request, 'admin/group_list.html', {'groups': groups})


/urls.py:
from django.urls import path
from users.views import sign_up,sign_in,sign_out,activate_user,admin_dashboard,assign_role,create_group,group_list


urlpatterns = [
    path('sign-up/', sign_up, name='sign-up'),
    path('sign-in/', sign_in, name='sign-in'),
    path('sign-out/', sign_out, name='sign-out'),
    path('activate/<int:user_id>/<str:token>/', activate_user, name='activate-user'),

    # Admin URLs
    path('admin/dashboard/', admin_dashboard, name='admin-dashboard'),
    path('admin/<int:user_id>/assign-role/', assign_role, name='assign-role'),
    path('admin/create-group/', create_group, name='create-group'),
    path('admin/group-list/', group_list, name='group-list'),
]


/signals.py:
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.auth.models import User, Group
from django.contrib.auth.tokens import default_token_generator
from django.core.mail import send_mail
from django.conf import settings


@receiver(post_save, sender=User)
def send_activation_email(sender, instance, created, **kwargs):
    if created and not instance.is_active:
        token = default_token_generator.make_token(instance)
        activation_url = f"{settings.SITE_URL}/activate/{instance.id}/{token}/"

        subject = 'Activate Your Account'
        message = (
            f"Hi {instance.username},\n\n"
            f"Please activate your account by clicking the link below:\n"
            f"{activation_url}\n\n"
            f"Thank you!"
        )
        recipient_list = [instance.email]

        try:
            send_mail(
                subject,
                message,
                settings.DEFAULT_FROM_EMAIL,
                recipient_list,
                fail_silently=False
            )
        except Exception as e:
            print(f"Activation email failed to send to {instance.email}: {str(e)}")


@receiver(post_save, sender=User)
def assign_default_role(sender, instance, created, **kwargs):
    if created:
        participant_group, _ = Group.objects.get_or_create(name='Participant')
        instance.groups.add(participant_group)


/forms.py:
from django import forms
import re
from django.contrib.auth.forms import AuthenticationForm
from django.contrib.auth.models import User, Group, Permission
from event.forms import StyledFormMixin

# Registration Form
class CustomRegistrationForm(StyledFormMixin, forms.ModelForm):
    password1 = forms.CharField(widget=forms.PasswordInput, label="Password")
    confirm_password = forms.CharField(widget=forms.PasswordInput, label="Confirm Password")

    class Meta:
        model = User
        fields = ['username', 'first_name', 'last_name', 'email', 'password1', 'confirm_password']

    def clean_email(self):
        email = self.cleaned_data.get('email')
        if User.objects.filter(email=email).exists():
            raise forms.ValidationError("Email already exists.")
        return email

    def clean_password1(self):
        password = self.cleaned_data.get('password1')
        errors = []

        if len(password) < 8:
            errors.append("Password must be at least 8 characters long.")
        if not re.search(r"[A-Z]", password):
            errors.append("Password must include at least one uppercase letter.")
        if not re.search(r"[a-z]", password):
            errors.append("Password must include at least one lowercase letter.")
        if not re.search(r"[0-9]", password):
            errors.append("Password must include at least one number.")
        if not re.search(r"[@#$%^&+=]", password):
            errors.append("Password must include at least one special character.")

        if errors:
            raise forms.ValidationError(errors)

        return password

    def clean(self):
        cleaned_data = super().clean()
        password1 = cleaned_data.get("password1")
        confirm_password = cleaned_data.get("confirm_password")

        if password1 and confirm_password and password1 != confirm_password:
            raise forms.ValidationError("Passwords do not match.")

        return cleaned_data

    def save(self, commit=True):
        user = super().save(commit=False)
        user.set_password(self.cleaned_data["password1"])
        user.is_active = False 
        if commit:
            user.save()
        return user

# Login 
class LoginForm(StyledFormMixin, AuthenticationForm):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


# Admin to assign roles
class AssignRoleForm(StyledFormMixin, forms.Form):
    role = forms.ModelChoiceField(
        queryset=Group.objects.all(),
        empty_label="Select a Role"
    )

# Admin create group assign permission
class CreateGroupForm(StyledFormMixin, forms.ModelForm):
    permissions = forms.ModelMultipleChoiceField(
        queryset=Permission.objects.all(),
        widget=forms.CheckboxSelectMultiple,
        required=False,
        label="Assign Permissions"
    )

    class Meta:
        model = Group
        fields = ['name', 'permissions']


/apps.py:
from django.apps import AppConfig

class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'users'

    def ready(self):
        import users.signals

it also has a templates folder but no html. provide required html files too.


now for the main project folder event_managemennt:
/urls.py:
from django.contrib import admin
from django.urls import path, include
from debug_toolbar.toolbar import debug_toolbar_urls
from core.views import home, no_permission
from django.conf import settings
from django.conf.urls.static import static


urlpatterns = [
    path('admin/', admin.site.urls),
    path('', home, name='home'),
    path('no-permission/', no_permission, name='no-permission'),
    path('users/', include('users.urls')),
    path('events/', include('event.urls')),
] + debug_toolbar_urls()

urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


/settings.py:
from pathlib import Path
import dj_database_url
from pathlib import Path
from decouple import *

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-4^u!z7r%ac6k0+@tvpjz35137x50e1srgr3+af)a=_1a6a^f*#'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['*']
CSRF_TRUSTED_ORIGINS =['https://*.onrender.com', 'http://127.0.0.1:8000']


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    "debug_toolbar",
    'core',
    'event',
    'users'
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    "debug_toolbar.middleware.DebugToolbarMiddleware",
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
INTERNAL_IPS = [
    # ...
    "127.0.0.1",
    # ...
]

ROOT_URLCONF = 'event_managemennt.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'event_managemennt.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

# DATABASES = {
#     'default': {
#         'ENGINE': 'django.db.backends.sqlite3',
#         'NAME': BASE_DIR / 'db.sqlite3',
#     }
# }

# DATABASES = {

#     'default': {

#         'ENGINE': 'django.db.backends.postgresql',

#         'NAME': 'event_managemennt', #database name

#         'USER': 'postgres',

#         'PASSWORD': 'Abrar161810161810?', #yourpassword

#         'HOST': 'localhost',

#         'PORT': '5432'

#     }

# }

DATABASES = {
    'default': dj_database_url.config(
        # Replace this value with your local database's connection string.
        default='postgresql://event_manager_db_kqug_user:rG3M4axCITjQHyNb78PrIWUHgRmWjWHd@dpg-d1j3mter433s73fpu110-a.oregon-postgres.render.com/event_manager_db_kqug',
        conn_max_age=600
    )
}

# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'
STATICFILES_DIRS = [
    BASE_DIR / 'static'
]

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

"saiyedul.abrar1430@gmail.com"

EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = config('EMAIL_HOST')
EMAIL_USE_TLS = config('EMAIL_USE_TLS', cast=bool)
EMAIL_PORT = config('EMAIL_PORT')
EMAIL_HOST_USER = config('EMAIL_HOST_USER')
EMAIL_HOST_PASSWORD = config('EMAIL_HOST_PASSWORD')


FRONTEND_URL = 'http://127.0.0.1:8000'

LOGIN_URL = 'sign-in'
SITE_URL = "http://127.0.0.1:8000"

.env file has:
#for email config
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_HOST_USER=saiyedul.abrar1430@gmail.com
EMAIL_HOST_PASSWORD=cxjzyleujvprqpef
EMAIL_USE_TLS=True


Design and name html files as per requirement. Careful: Admin can see everything and have access to every dashboard which he will see as option on admin dashboard. Organizer will see Organizer's dashboard where he can create, update, and delete events and categories. Participants can only view events on participants dashboard. after clicking on details he will see event details and a RSVP button.

Using tailwindcdn:
<script src="https://cdn.tailwindcss.com"></script>

make it look good and professional and responsive.
There are five breakpoints by default, inspired by common device resolutions:
sm	640px	
md	768px	
lg	1024px	
xl	1280px	
2xl	1536px	


